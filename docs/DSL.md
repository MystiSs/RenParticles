# RenParticles DSL - Руководство пользователя

## Введение

RenParticles — это система частиц для Ren'Py с собственным DSL (предметно-ориентированным языком). Вместо написания Python-кода вы описываете поведение частиц декларативно, используя простой синтаксис.

## Быстрый старт

```renpy
rparticles as my_particles onlayer master zorder 1:
    sprite expr Solid("#ff0000", xysize=(12, 12))
    lifetime range random (1.0, 3.0)
    redraw asap
    
    preset spray:
        amount 100
    
    preset auto_expire
```

Этот код создаст 100 красных квадратных частиц со случайным временем жизни от 1 до 3 секунд.

---

## Основной синтаксис

### Объявление системы частиц

```renpy
rparticles [model "model_name"] [as tag] [onlayer layer_name] [zorder z] [multiple]:
    # содержимое системы
```

**Параметры:**
- `model "name"` — использовать предопределенную модель
- `as tag` — тег для управления системой (по умолчанию `rparticles_displayable`)
- `onlayer layer_name` — слой отображения (по умолчанию `master`)
- `zorder z` — порядок отрисовки (по умолчанию `0`)
- `multiple` — создать группу из нескольких подсистем

### Спрайты частиц

Определяют внешний вид частиц:

```renpy
sprite image_tag
sprite expr Solid("#ff0000", xysize=(12, 12))
sprite image1; image2; expr Solid("#00ff00", xysize=(8, 8))
```

- Обычный тег изображения: `sprite my_particle_image`
- Python-выражение: `sprite expr <expression>`
- Несколько вариантов через `;` — система выберет случайный

### Время жизни частиц

```renpy
lifetime constant 2.0
lifetime range random (1.0, 3.0)
```

- `constant <число>` — фиксированное время жизни
- `range random (<мин>, <макс>)` — случайное время в диапазоне

### Частота обновления

```renpy
redraw 0.0          # максимальная частота
redraw asap         # то же самое
redraw 0.016        # ~60 FPS
redraw None         # обновление по умолчанию
```

Меньшее значение = более плавная анимация, но выше нагрузка.

## Блоки поведения

### on update

Выполняется каждый кадр для каждой частицы:

```renpy
on update:
    move:
        velocity [0.0, 100.0]
        acceleration [0.0, 50.0]
    
    auto_expire
```

### on event

Реагирует на события мыши:

```renpy
on event:
    repulsor_event
```

### on particle dead

Выполняется когда частица умирает:

```renpy
on particle dead:
    emitter spray:
        amount 3
```

## Эмиттеры

Эмиттеры создают новые частицы.

### Behavior: spray

Создает частицы единовременно:

```renpy
emitter spray oneshot:
    amount 100
    area (0, 0, 1920, 1080)
```

**Параметры:**
- `amount` — количество частиц (обязательно)
- `area` — область генерации `(x1, y1, x2, y2)` (по умолчанию весь экран)

### Behavior: interval_spray

Создает частицы с интервалом:

```renpy
emitter interval_spray:
    amount 500
    interval 0.05
    per_amount 10
```

**Параметры:**
- `amount` — общее количество частиц
- `interval` — интервал между генерациями (секунды)
- `per_amount` — частиц за раз (по умолчанию 1)
- `kill_on_finish` — удалить эмиттер после завершения (по умолчанию True)

---

## Behavior: fragmentation (interval_fragmentation_per_particle)

Этот обработчик позволяет одной системе (донору) создавать частицы в другой системе (ресивере). Он используется для создания следов (trails), каскадных взрывов или сложных погодных эффектов.

### Синтаксис:

```renpy
# В блоке поведения (on update)
interval_fragmentation_per_particle system "id_системы":
    amount 1      # Количество создаваемых частиц за один такт
    interval 0.1  # Частота создания (в секундах)

```

### Параметры:

* **`system "id"`** (string): Уникальный идентификатор целевой системы, в которой будут рождаться новые частицы.
* **`amount`** (int): Сколько частиц будет создано за раз при срабатывании интервала.
* **`interval`** (float): Задержка между циклами генерации.

### Нюансы работы и архитектура

#### 1. Контекстная зависимость (`_has_particle`)

Обработчик автоматически определяет свою роль при первом запуске:

* **Если вызван внутри `on update` частицы без ключевого слова `emitter`**: Он становится «локальным». Каждая родительская частица получает свой собственный таймер. Это позволяет создавать уникальные следы, которые следуют за каждой частицей индивидуально.
* **Если вызван на уровне системы**: Он работает как обычный интервальный эмиттер, создавая частицы в координатах $(0, 0)$ целевой системы.

#### 2. Механика «Следа» (Trails)

Когда частица-родитель движется, она передает свои текущие координаты `x` и `y` создаваемым частицам в целевой системе.

> **Важно:** Созданные частицы «отрываются» от родителя. Они появляются в его позиции, но дальше живут по правилам своей собственной системы (у них может быть своя скорость, гравитация и время жизни).

#### 3. Изоляция таймеров

Благодаря использованию `particles_properties` и уникальных счетчиков (`_RENP_INT_REM_EM`), таймеры разных фрагментаторов не конфликтуют. Если у частицы есть два разных следа (например, дым и искры), они будут генерироваться независимо друг от друга.

#### 4. Работа в одной системе

Если не указывать `system "id"` или указать недействительный `id`, то эмиттер будет работать в текущей системе (там, где его определили).

### Примеры использования

#### Создание «ракеты» с дымным следом:

В этом примере система `rocket` летит вверх и каждые 0.05 секунд оставляет после себя частицу в системе `smoke_trail`.

```renpy
rparticles define multiple "projectile":
    system id "smoke_trail":
        # ... настройки дыма (плавное исчезновение, подъем вверх) ...
        preset auto_expire
        
    system id "rocket":
        # ... настройки самой ракеты ...
        on update:
            move:
                velocity [0, -500]
            
            # Генерация следа
            interval_fragmentation_per_particle system "smoke_trail":
                amount 1
                interval 0.05

```

### Технические особенности для документации:

* **UpdateState.Pass**: Обработчик всегда возвращает `Pass`, так как он не изменяет состояние текущей частицы, а лишь инициирует побочный эффект в другой системе.
* **Производительность**: Использование очень малых интервалов (менее 0.02) при большом количестве родительских частиц может привести к экспоненциальному росту количества объектов в памяти. Рекомендуется комбинировать фрагментацию с `preset auto_expire` в целевой системе.
* **Копирование координат**: Новые частицы получают значения `sprite.x` и `sprite.y` в момент создания. Если целевая система имеет смещение (offset), оно будет применено поверх этих координат.

---

## Поведения частиц

### Behavior: auto_expire или preset: auto_expire

Автоматически уменьшает время жизни и удаляет частицы:

```renpy
auto_expire
```

---

## Behavior: move

Обработчик `move` отвечает за физическое перемещение частиц в пространстве системы. Он реализует классическую модель движения, где на каждом шаге скорость частицы меняет её положение, а ускорение — саму скорость.

### Параметры блока `move`:

* **`velocity`** `[x, y]` (list of floats): Начальная скорость частицы в пикселях в секунду.
* **`velocity_range`** `[x, y]` (list of floats): Радиус случайного разброса для начальной скорости. Финальное значение вычисляется как `velocity ± random(velocity_range)`.
* **`acceleration`** `[x, y]` (list of floats): Постоянное ускорение (например, гравитация).
* **`acceleration_range`** `[x, y]` (list of floats): Радиус случайного разброса для ускорения. Позволяет сделать так, чтобы частицы в одном потоке падали или взлетали с разной интенсивностью.

### Примеры использования

#### 1. Эффект фонтана (Гравитация)

Частицы вылетают вверх с разбросом и со временем начинают падать вниз под действием ускорения.

```renpy
on update:
    move:
        velocity [0.0, -400.0]        # Резко вверх
        velocity_range [100.0, 50.0]  # Небольшой разброс по сторонам
        acceleration [0.0, 800.0]     # Сильная гравитация вниз

```

#### 2. Ветер или снос

Частицы медленно плывут в сторону, постепенно ускоряясь.

```renpy
on update:
    move:
        velocity [50.0, 0.0]
        acceleration [20.0, 5.0]     # Легкий импульс вправо и вниз
        acceleration_range [5.0, 2.0] # Неоднородность потока

```

### Технические особенности реализации

1. **Двойной проход**: Обработчик обновляет состояние в два этапа:
* Сначала меняются координаты `x` и `y` на основе текущей скорости.
* Затем сама скорость обновляется на основе ускорения.
Это обеспечивает корректное параболическое движение.


2. **Перманентность состояния**: В отличие от чисто визуальных трансформаций, значения `velocity` и `acceleration` вычисляются один раз при инициализации частицы и сохраняются в `particles_properties`. Это гарантирует, что «физический профиль» частицы не изменится до конца её жизни.
3. **Независимость осей**: Расчеты по осям X и Y полностью разделены, что позволяет имитировать сложные силы, например, сильное боковое сопротивление при слабом вертикальном падении.
4. **Delta-time Scaling**: Все расчеты умножаются на `delta` (время прошедшее с последнего кадра), что делает движение плавным и независимым от частоты кадров (FPS) монитора.

### Важное примечание по координатам:

Обработчик `move` напрямую изменяет свойства `particle.x` и `particle.y`. Эти координаты определяют положение **центра** частицы (благодаря автоматическому смещению `size/2` в системе отрисовки).

---

## Behavior: simple_move

Обработчик `simple_move` реализует равномерное прямолинейное движение. Скорость частицы задаётся один раз при её рождении и остаётся неизменной на протяжении всей её жизни.

### Параметры блока `simple_move`:

* **`velocity`** `[x, y]` (list of floats): Вектор скорости (пиксели в секунду).
* **`velocity_range`** `[x, y]` (list of floats): Диапазон случайного отклонения скорости по осям. Финальная скорость частицы рассчитывается как `velocity ± random(velocity_range)`.

---

### Примеры использования

#### 1. Прямой поток (Лазер или пули)

Все частицы летят с одинаковой скоростью в одном направлении.

```renpy
on update:
    simple_move:
        velocity [1000.0, 0.0]  # Быстрый полет вправо

```

#### 2. Рассеянный взрыв (без гравитации)

Частицы разлетаются из центра во все стороны и продолжают движение по инерции.

```renpy
on update:
    simple_move:
        velocity [0.0, 0.0]
        velocity_range [300.0, 300.0] # Разлет в случайном направлении

```

### Технические особенности реализации

1. **Линейная инерция**: В отличие от основного обработчика `move`, здесь отсутствует вектор ускорения (`acceleration`). Скорость (`velocity`) вычисляется методом `_get_velocity()` только один раз.
2. **Оптимизация производительности**: Поскольку скорость константна, движку не нужно выполнять операции сложения для изменения вектора скорости в каждом кадре. Это делает `simple_move` идеальным выбором для систем с очень большим количеством частиц (например, плотный снег или дождь без ветра).
3. **Сохранение состояния**: Вектор скорости сохраняется в `particles_properties` под уникальным ключом `_renp_simple_vel`. Это гарантирует, что даже если в системе произойдёт `freeze` или пауза, после возобновления частица продолжит движение по той же траектории.
4. **Delta-time**: Позиция обновляется с учётом времени кадра (`delta`), что обеспечивает одинаковую скорость движения как при 30 FPS, так и при 144 FPS.

### Сравнение с Move:

| Особенность | Move | SimpleMove |
| --- | --- | --- |
| **Ускорение** | Поддерживается | Нет |
| **Траектория** | Параболическая (кривая) | Прямая |
| **Нагрузка** | Средняя | Низкая |
| **Применение** | Гравитация, физика, дым | Осадки, пули, простые фоны |

---

## Behavior: rotate

Обработчик `rotate` управляет вращением спрайтов частиц. Он позволяет задавать как начальный угол поворота (фазу), так и постоянную скорость вращения с возможностью рандомизации для каждой отдельной частицы.

### Параметры блока `rotate`:

* **`speed`** (float): Базовая скорость вращения в градусах в секунду. По умолчанию `360.0`.
* **`speed_range`** (float): Диапазон случайного отклонения скорости. Итоговая скорость будет в пределах `[speed - speed_range, speed + speed_range]`.
* **`phase`** (float): Базовый начальный угол поворота в градусах.
* **`phase_range`** (float): Диапазон случайного отклонения начального угла. Итоговая фаза будет в пределах `[phase - phase_range, phase + phase_range]`.

### Примеры использования

#### 1. Хаотичное вращение (Искры/Осколки)

Каждая частица получает случайную начальную ориентацию и уникальную скорость вращения.

```renpy
on update:
    rotate:
        speed 180.0       # Базовая скорость
        speed_range 360.0 # Скорость от -180 до +540 град/сек
        phase_range 360.0 # Случайный начальный поворот (0-360)

```

#### 2. Равномерное медленное вращение (Снежинки/Листья)

Частицы медленно вращаются в одну сторону с небольшим разбросом скоростей.

```renpy
on update:
    rotate:
        speed 45.0
        speed_range 15.0  # Скорость от 30 до 60 град/сек
        phase_range 90.0

```

### Технические особенности реализации

1. **Центрирование**: Вращение происходит вокруг геометрического центра спрайта (благодаря автоматическому смещению `size/2` в движке), что исключает вращение вокруг угла.
2. **Накопительный эффект**: В отличие от `tween`, который задает абсолютные значения, `rotate` накапливает угол поворота (`total_rotation`) каждый кадр на основе `delta`. Это позволяет частицам вращаться бесконечно долго без рывков.
3. **Изоляция данных**: Параметры `speed` и `phase` вычисляются один раз при инициализации частицы в `_get_initial_data` и сохраняются в `particles_properties`. Это гарантирует, что скорость вращения частицы не изменится в течение всей её жизни.
4. **Queue Transform**: Использует `particle.queue_transform(rotate=...)`, что позволяет комбинировать вращение с другими трансформациями (например, `zoom` или `alpha` из блоков `tween`) без их взаимного перезаписывания.
> **Важное примечание:** Метод `.queue_transform(...)` **не является** аддитивным или мультипликативным. Он просто записывает значение в очередь на применение. Если два разных обработчика (например, два разных блока `rotate` или `tween`) попытаются изменить одно и то же свойство в одном цикле `update`, **последний** вызвавший метод перезапишет значение предыдущего.

---

### Подсказка для разработчика:

Использование `phase_range 360.0` — это самый простой и эффективный способ избавиться от визуальной повторяемости (паттернов) в системе частиц, так как даже одинаковые спрайты будут выглядеть по-разному под случайными углами.

---

## Behavior: oscillate

Обработчик `oscillate` добавляет к текущим координатам частицы колебательную составляющую на основе функции синуса. Это движение накладывается поверх любых других перемещений (например, `move` или `simple_move`).

### Параметры блока `oscillate`:

* **`amplitudes`** `[x, y]` (list of floats): Максимальное отклонение от центральной точки по осям X и Y.
* **`frequencies`** `[x, y]` (list of floats): Количество полных колебаний в секунду.
* **`phases`** `[x, y]` (list of floats): Начальный сдвиг фазы (в радианах). Позволяет частицам в одной системе колебаться несинхронно.
* **`amplitudes_range` / `frequencies_range` / `phases_range`**: Случайные отклонения соответствующих параметров, вычисляемые индивидуально для каждой частицы при её создании.

### Примеры использования

#### 1. Эффект «плавающих» светлячков

Медленные, хаотичные колебания по обеим осям.

```renpy
on update:
    oscillate:
        amplitudes [30.0, 30.0]
        amplitudes_range [10.0, 10.0]
        frequencies [0.5, 0.5]
        phases_range [6.28, 6.28] # Рандомная начальная фаза (0 - 2pi)

```

#### 2. Падающий лист (Зигзаг)

Комбинация с `simple_move`. Лист падает вниз, покачиваясь из стороны в сторону по горизонтали.

```renpy
on update:
    simple_move:
        velocity [0.0, 100.0]
    oscillate:
        amplitudes [50.0, 0.0]  # Колебания только по X
        frequencies [1.5, 0.0]

```

### Технические особенности и нюансы

1. **Аддитивность**: Обработчик является **аддитивным**. Это значит, что он не устанавливает координату частицы, а прибавляет вычисленное смещение к текущему значению `particle.x` и `particle.y`. Это позволяет использовать несколько блоков `oscillate` одновременно для создания сложных фигур Лиссажу.
2. **Накопление ошибки (Drift)**: Поскольку смещение вычисляется на основе `delta` и прибавляется каждый кадр, со временем может накапливаться математическая погрешность (ошибка плавающей точки).
* *Что это значит:* При очень длительном времени жизни частицы её "центр колебаний" может незначительно сместиться относительно первоначальной траектории. Для кратковременных эффектов это незаметно.


3. **Независимость параметров**: Каждая ось (X и Y) имеет собственный таймер и набор настроек, что позволяет создавать круговые или эллиптические движения, если задать одинаковые частоты, но разные фазы.
4. **Производительность**: Использует функцию `math.sin`, что несколько тяжелее простого `move`, но благодаря хранению предвычисленных параметров в `particle_data`, обсчет остается эффективным даже для сотен частиц.

### Математическая справка:

Смещение в каждом кадре рассчитывается по формуле:

$$\Delta = A \cdot \sin(2\pi \cdot f \cdot t + \phi) \cdot dt$$

Где $A$ — амплитуда, $f$ — частота, $t$ — накопленное время жизни, $\phi$ — фаза, а $dt$ — время кадра (`delta`).

---

Этот обработчик превращает частицы в «интерактивный рой», который динамически реагирует на положение курсора пользователя. Это не просто вращение по кругу, а полноценная симуляция притяжения к подвижной орбите.

---

## Behavior: orbit_mouse или preset orbit_mouse

Поведение `orbit_mouse` заставляет частицы стремиться к круговой орбите вокруг текущей позиции мыши и вращаться по ней. Благодаря параметру `pull_strength`, частицы могут мягко подлетать к курсору из любой точки экрана, создавая эффект органического притяжения.

### Параметры блока `orbit_mouse`:

* **`radius`** (float): Желаемый радиус орбиты в пикселях. По умолчанию `100.0`.
* **`speed`** (float): Базовая угловая скорость вращения. По умолчанию `10.0`.
* **`speed_variance`** (float): Разброс скорости для каждой частицы (коэффициент 0.0–1.0). Позволяет частицам в рое двигаться с разным темпом. По умолчанию `0.5`.
* **`pull_strength`** (float): Сила притяжения к идеальной точке на орбите (0.0–1.0). Чем выше значение, тем жестче частица «прикована» к радиусу. По умолчанию `0.5`.
* **`clockwise`** (bool): Направление вращения. `True` — по часовой стрелке, `False` — против.
* **`screen_bounds`** (bool): Если `True`, частицы не смогут вылететь за границы игрового окна (удерживаются в пределах 2 пикселей от края). По умолчанию `True`.

### Примеры использования

#### 1. Плотное магическое кольцо вокруг курсора

Частицы быстро и жестко следуют за мышью.

```renpy
on update:
    orbit_mouse:
        radius 80.0
        speed 15.0
        pull_strength 0.8
        speed_variance 0.2

```

#### 2. Ленивый рой «светлячков»

Мягкое притяжение и большой разброс скоростей создают эффект живого облака.

```renpy
on update:
    orbit_mouse:
        radius 200.0
        speed 3.0
        pull_strength 0.1
        speed_variance 0.8
        clockwise False

```

### Технические особенности реализации

1. **Динамический захват**: Если расстояние до мыши становится критически малым (< 1 пикселя), обработчик автоматически «выбрасывает» частицу на заданный радиус под случайным углом, чтобы избежать деления на ноль в расчетах и визуального "слипания".
2. **Векторная математика**:
* Алгоритм вычисляет нормализованный вектор от мыши к частице (`nx`, `ny`).
* На основе направления (`clockwise`) создается перпендикулярный вектор для вращения.
* Финальная позиция частицы — это интерполяция между её текущим местоположением и целевой точкой на орбите, умноженная на `pull_strength`.


3. **Индивидуальность**: Скорость каждой частицы вычисляется один раз при инициализации с учетом `speed_variance` и сохраняется в `_orbit_speed`. Это предотвращает «марширование строем» и делает рой хаотичным и живым.
4. **Безопасность (Screen Bounds)**: Встроенная проверка границ гарантирует, что даже при резком рывке мыши частицы не «улетят в бесконечность», что критично для интерактивных меню.

### Нюанс для разработчика:

Этот обработчик лучше всего работает как **единственный** контроллер позиции. Если вы добавите `move` или `oscillate` в тот же блок `on update`, частицы могут начать вести себя непредсказуемо (дрожать или улетать по спирали), так как `orbit_mouse` постоянно перезаписывает координаты `particle.x/y`, пытаясь вернуть их на орбиту.

---

## Behavior: repulsor

*Этот функционал основан на классическом примере из документации Ren'Py, но адаптирован под архитектуру RenParticles с разделением на обновление (update).*

Связка `repulsor_update` и `repulsor_event` создает зону отталкивания. Когда курсор мыши оказывается рядом с частицей, она выталкивается за пределы указанного радиуса.

### Синтаксис:

```renpy
on update:
    repulsor_update:
        strength 5.0     # Сила импульса
        radius 200.0     # Дистанция влияния
        clamp_margin 2.0 # Удержание внутри экрана

on event:
    repulsor_event       # Передает координаты мыши в систему

```

### Параметры:

* **`strength`** (float): Сила, с которой частица выталкивается от центра. По умолчанию `3.0`.
* **`radius`** (float): Радиус действия «репульсора». Если частица дальше этого расстояния, эффект не применяется. По умолчанию `150.0`.
* **`clamp_margin`** (float): Отступ от краев системы, чтобы частицы, выталкиваемые за экран, не исчезали полностью, а «прилипали» к краю. По умолчанию `2.0`.

### Как это работает (Архитектура)

1. **Событийный слой (`repulsor_event`)**: Этот обработчик срабатывает при движении мыши над областью частиц. Он записывает текущие координаты `x, y` в общее хранилище данных системы (`system.particles_data.repulsor_pos`). Это избавляет каждую частицу от необходимости опрашивать движок Ren'Py напрямую.
2. **Слой обновления (`repulsor_update`)**:
* В каждом кадре частица проверяет наличие `repulsor_pos`.
* Вычисляется вектор между частицей и «репульсором».
* **Затухание (Falloff)**: Сила отталкивания не постоянна. Она максимальна в центре и линейно убывает до нуля к границе радиуса. Это создает эффект мягкого выталкивания, а не резкого телепорта.
* **Ограничение (Clamp)**: Если сила выталкивает частицу за пределы области `width/height`, обработчик принудительно возвращает её на границу с учетом `clamp_margin`.

### Примеры использования

#### 1. Интерактивное облако (эффект «раздвигания» тумана)

Частицы медленно парят, но разлетаются, если навести на них мышь.

```renpy
rparticles define preset interactive_fog:
    on update:
        simple_move:
            velocity [10, 0]
        repulsor_update:
            strength 4.0
            radius 180.0
    on event:
        repulsor_event

```

#### 2. Защитный барьер

Если задать очень высокую силу, мышь будет работать как непроницаемый щит для частиц.

```renpy
on update:
    repulsor_update:
        strength 50.0 # Мгновенное выталкивание
        radius 100.0

```

### Нюансы реализации

* **Связка обязательна**: `repulsor_update` сам по себе не знает, где находится мышь. Ему нужны данные, которые поставляет `repulsor_event`.
* **Тип контекста**: В коде предусмотрена строгая проверка: `repulsor_event` может работать только в `on event`, так как ему необходим `EventContext` (содержащий координаты события). Попытка вызвать его в `on update` вызовет понятную ошибку.
* **Аддитивность**: Как и осциллятор, этот обработчик изменяет `p.x/y` напрямую, прибавляя силу к текущей позиции. Это значит, что он отлично сочетается с любыми методами движения (`move`, `simple_move`), работая как «внешняя сила».

### Использование готового пресета:

Существует пресет глобального уровня `repulsor`, который позволяет подключить всё сразу одной строкой.
Пресет является статическим, а значит он знает как распределить переопределяемые параметры:

```renpy
rparticles define system "my_system":
    preset repulsor:
        strength 10.0
        radius 250.0

```

---

## Behavior: tween

Обработчик `tween` предназначен для плавного изменения свойств трансформации спрайта (alpha, zoom, rotate и др.) во времени. Поддерживает как фиксированные временные интервалы, так и динамическую привязку к жизненному циклу частицы.

### Параметры блока `block`:

* **`time`** (float): Длительность анимации. В режиме `absolute` — секунды, в режиме `lifetime` — коэффициент (0.0–1.0).
* **`start_value`** (float): Начальное значение свойства.
* **`end_value`** (float): Конечное значение свойства.
* **`warper`** (string): Функция интерполяции (названия стандартных варперов Ren'Py: `"linear"`, `"ease"`, `"expo"`, `"circ"` и т.д.). По умолчанию `"linear"`.
* **`mode`** (string): Режим расчета времени:
* `"absolute"` (по умолчанию): `time` трактуется как фиксированное время в секундах.
* `"lifetime"`: `time` трактуется как доля от общего времени жизни частицы.


* **`from_end`** (bool): Если `True`, анимация начнется в конце жизни частицы так, чтобы завершиться ровно в момент её исчезновения.

### Примеры использования

#### 1. Базовая анимация (Абсолютное время)

Простое появление и уменьшение спрайта при создании.

```renpy
on update:
    tween:
        block "alpha":
            time 0.5
            start_value 0.0
            end_value 1.0
        block "zoom":
            time 1.0
            start_value 2.0
            end_value 1.0
            warper "ease"

```

#### 2. Адаптивная анимация (Lifetime mode)

Анимация, которая подстраивается под время жизни частицы. Если частица живет 2 секунды, альфа проявится за 0.4с. Если живет 10 секунд — за 2с.

```renpy
on update:
    tween:
        block "alpha":
            mode "lifetime"
            time 0.2  # 20% от времени жизни на проявление
            start_value 0.0
            end_value 1.0

```

#### 3. Анимация исчезновения (from_end)

Идеально для плавного затухания частиц перед их удалением. Анимация начнется автоматически, исходя из оставшегося времени жизни.

```renpy
on update:
    # Анимировать альфу до 0.0 в последние 0.5 секунд жизни
    tween:
        block "alpha":
            from_end True
            time 0.5
            start_value 1.0
            end_value 0.0

```

### Технические особенности реализации

1. **Многопоточность свойств**: Внутри одного блока `tween` можно описывать несколько `block` для разных свойств. Они будут выполняться параллельно и независимо.
2. **Уникальность состояний**: Каждая частица хранит свой прогресс анимации в `particles_properties` под уникальным ключом, что исключает конфликты при использовании нескольких `tween` в одной системе.
3. **Оптимизация**: После завершения всех анимаций в блоке, обработчик выставляет флаг `_completed` и перестает производить вычисления в `__call__`, просто пропуская итерации (UpdateState.Pass).
4. **Безопасность**: Все значения на выходе проходят через `_renp_clamp`, предотвращая выход за границы диапазона `[start, end]`, что критично при использовании сложных варперов с "отскоками".

**Параметры блока:**
- `time` — длительность анимации (секунды)
- `start_value` — начальное значение
- `end_value` — конечное значение
- `warper` — функция интерполяции (по умолчанию "linear")

**Доступные свойства:** alpha, zoom, xzoom, yzoom, rotate, xpos, ypos и другие свойства Transform.

---

## Пресеты

Пресеты — готовые комбинации поведений.

### Встроенные пресеты

```renpy
preset spray:
    amount 100

preset interval_spray:
    amount 500
    interval 0.05

preset auto_expire

preset repulsor:
    strength 5.0
    radius 200.0

preset orbit_mouse:
    speed 10.0
    pull_strength 0.5
```

### Создание собственных пресетов

```renpy
init 100:
    rparticles define preset my_preset type general:
        on update:
            move:
                velocity [0.0, 100.0]
                acceleration [0.0, 50.0]
            
            tween:
                block "alpha":
                    time 1.0
```

**Типы пресетов:**
- `type general` — используется на верхнем уровне системы
- `type inner` — используется внутри блоков on update/event/particle dead

### Технические особенности реализации
1. **Одноуровневость**: Рекурсивные пресеты недоступны 
2. **Диспетчеризация параметров**: Динамические пресеты не знают как передавать переопределяемые параметры (когда вы при использовании пресета в системе открываете блок параметров). Такие параметры никуда не пойдут, хотя и есть возможность их задавать. Имейте это ввиду.

## Множественные системы

Создание нескольких независимых систем частиц:

```renpy
rparticles multiple as particles onlayer master:
    redraw asap
    
    system id "fire":
        sprite expr Solid("#ff4400", xysize=(8, 8))
        lifetime constant 1.0
        
        preset interval_spray:
            amount 100
            interval 0.01
        
        on update:
            move:
                velocity [0.0, -100.0]
            auto_expire
    
    system id "sparks":
        sprite expr Solid("#ffff00", xysize=(4, 4))
        lifetime range random (0.5, 1.5)
        
        preset spray:
            amount 50
        
        on update:
            move:
                velocity [0.0, 0.0]
                velocity_range [200.0, 200.0]
            auto_expire
```

Взаимодействие между системами:

```renpy
on update:
    interval_fragmentation_per_particle system "sparks":
        amount 3
        interval 0.2
```

## Модели (шаблоны)

Сохранение конфигурации для повторного использования:

```renpy
init:
    rparticles define "explosion_effect":
        sprite expr Solid("#ff0000", xysize=(16, 16))
        lifetime range random (0.5, 1.5)
        redraw asap
        
        preset spray:
            amount 200
        
        on update:
            move:
                velocity [0.0, 0.0]
                velocity_range [300.0, 300.0]
                acceleration [0.0, 500.0]
            
            tween:
                block "alpha":
                    time 1.0
                block "zoom":
                    time 1.0
                    start_value 1.5
                    end_value 0.0
            
            auto_expire

label game:
    # Использование модели
    rparticles model "explosion_effect" as explosion1
```

## Управление системами

### Команды управления

```renpy
# Показать систему
rparticles model "my_model" as particles

# Сбросить систему (удалить все частицы, перезапустить эмиттеры)
rparticles reset "particles"

# Заморозить систему (остановить обновление)
rparticles freeze "particles"

# Разморозить систему
rparticles unfreeze "particles"
rparticles unfreeze "particles" noredraw

# Управление подсистемами
rparticles freeze "particles"."fire"
rparticles unfreeze "particles"."sparks" noredraw

# Скрыть систему
hide particles

# Показать снова
rparticles continue "particles" onlayer master zorder 1

# Очистить кэш
rparticles clear cache        # удалить скрытые системы
rparticles clear cache deep   # удалить все системы
```

## Продвинутые возможности

### Пользовательские функции

Вместо шорткатов можно использовать Python-классы отнаследованные от _Behavior, Emitter:

```renpy
on update:
    custom my_custom_Behavior oneshot
    custom my_custom_Behavior system "target_system"
```

### Модификатор oneshot

Выполнить поведение один раз:

```renpy
on update:
    emitter spray oneshot:
        amount 100
```

### Динамические свойства

Для сложных конфигураций:

```renpy
tween:
    block "alpha":
        time 0.5
    block "zoom":
        time 1.0
        start_value 2.0
        end_value 0.5
        warper "easein"
```

## Примеры

### Простой дождь

```renpy
rparticles as rain onlayer master:
    sprite expr Solid("#4488ff", xysize=(2, 8))
    lifetime constant 3.0
    redraw 0.016
    
    preset interval_spray:
        amount 1000
        interval 0.01
        per_amount 5
    
    on update:
        move:
            velocity [0.0, 500.0]
        auto_expire
```

### Фейерверк (Пример сложной цепочки)

```renpy
rparticles multiple as firework:
    system id "trail":
        sprite expr Solid("#ffffff", xysize=(2, 2))
        lifetime constant 0.5
        on update:
            tween:
                block "alpha": 
                    from_end True
                    time 0.5
                    start_value 1.0
                    end_value 0.0
            auto_expire

    system id "shell":
        sprite expr Solid("#ffff00", xysize=(4, 4))
        lifetime constant 1.5
        on update:
            move:
                velocity [0, -400]
                acceleration [0, 200]
            # Создаем след из системы trail
            interval_fragmentation_per_particle system "trail":
                amount 1
                interval 0.02
            auto_expire
        # Взрыв при смерти "снаряда"
        on particle dead:
             emitter spray oneshot:
                amount 50
                # Здесь можно добавить логику разлета осколков
```

### Магический эффект

```renpy
rparticles as magic onlayer master:
    sprite expr Solid("#aa00ff", xysize=(12, 12))
    lifetime range random (2.0, 4.0)
    redraw asap
    
    preset interval_spray:
        amount 200
        interval 0.02
    
    on update:
        orbit_mouse:
            radius 100.0
            speed 8.0
            pull_strength 0.2
        
        tween:
            block "alpha":
                time 2.0
        
        auto_expire
```

## Советы по производительности

1. Используйте `redraw 0.016` вместо `asap` если не нужна максимальная частота
2. Ограничивайте количество одновременных частиц
3. Используйте `lifetime` для автоматического удаления частиц
4. Для статичных эффектов используйте `cache`
5. Группируйте похожие частицы в одну систему

## Отладка

Система выводит информацию о конфигурации в консоль при создании. Проверьте консоль Ren'Py для диагностики проблем.

## Ограничения

- Спрайты рисуются со смещением `размер_спрайта / 2` от указанной позиции
- Рекурсивные пресеты не поддерживаются
- Максимальная производительность зависит от количества частиц и сложности поведений
